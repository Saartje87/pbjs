{"google":"UA-31724729-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Pbjs","tagline":"pbjs oop javascript framework","body":"pbjs\r\n==========================================================\r\n\r\nAbout\r\n-----\r\n\r\n*pbjs* is small and lightweight object orientated framework (*Production size:* [~10kb](https://github.com/Saartje87/pbjs/tree/master/bin/pbjs.min.js)).\r\n\r\nCompared to other DOM based alternatives, like jQuery, [Zepto](http://zeptojs.com/) or [QuoJS](http://quojs.tapquo.com/), it has a focus on cross-browser/device compatibility and performance. Through the modular design it can be extended with various plugins.\r\n\r\n\r\n\r\nConcept\r\n-------\r\n\r\nThe usage of *pbjs* is quite easy, especially if you are familiar with other frameworks. Every method mentioned in the docs is a part of the global 'PB'-object. Some of the methods needs to be used on a wrapped element, but most general tasks could be used solely.\r\n\r\nSince a reference to itself will always be returned - fluent programming via method chaining is possible.\r\n\r\nIn contrast to most AJAX libraries, pbjs was created for developing interactive web applications instead of effects or widgets.\r\n\r\n*pbjs* focuses on `efficient coding` to improve the performance.\r\n\r\nFollowing this principle it forces the developer to use best practice solutions in JavaScript and an appropriate coding style.\r\n\r\nA few ways to achieve this:\r\n\r\n- usage of native functions instead of custom regex matches: the general element selector will be an element ID\r\n- caring about bottlenecks, especially the DOM: everything will be cached internaly to simplify the re-usage\r\n- dont repeat yourself (DRY): using clear function names to avoid multiple declarations for the same purpose\r\n- the future right now: instead of custom calls for general tasks, ES5 polyfills are included\r\n- supporting OOP approaches: ease the paradigm through the included class construct & inheritance\r\n- don't wait for it: the framework is defined in the CommonJS way for async module loading\r\n- understand what you do: find a method in the modular structured source\r\n\r\nOf course it works quite well with common [design patterns](http://addyosmani.com/resources/essentialjsdesignpatterns/book/).\r\n\r\n\r\n\r\nUsage\r\n-----\r\n\r\nBy default elements used by the pbjs will be cached. A garbage collector will free the memory when they are removed from the DOM trough emptying the html. To compensate the cost of rarely used object it is neccessary to create new ones or keep them alive (*see PB.Request*).\r\n\r\n\r\n### Wrapper (Selector & Create)\r\n\r\nThe 'PB'-object can use input for different purposes:\r\n\r\n1. Element ID - selector \r\n\r\n        // Retrieve single element    \r\n        PB('element_id')\r\n\r\n2. DOM node selector (regular & cached)\r\n        \r\n        // Select single element\r\n        PB(document.body)\r\n\r\n3. creating elements\r\n\r\n        // Create an element     \r\n        PB('<h1>Peanut Butter and Jelly Sandwich!</h1>').appendTo( [Object PBDom] )\r\n\r\n### Request\r\n\r\nTo do a HTTP-Request, a new Request-Object has to be created and configured with data.\r\n\r\n    // Create & configure a new request object\r\n    var req = new PB.Request({\r\n    \r\n        url: '42.nl',\r\n        data:{ \r\n            foo: 'bar'\r\n        },\r\n        method: 'POST'        \r\n    });\r\n    \r\nAfterwards a callback can be declared, which should be triggered on the result of the sending.\r\n        \r\n    // Attach listener & callback\r\n    req.on('success', function ( res ) {\r\n        \r\n        // represents the response as an object\r\n        console.log( res.responseJSON );\r\n        \r\n    }).send();\r\n    \r\n\r\n### Collections\r\n\r\nCollections in *pbjs* are used to select a set of elements. Methods which are supposed to output multiple values returns a collection. \r\n\r\n    // Store collection, crawling is heavy :)\r\n    var collection = PB('element_id').find('div.peanut);\r\n\r\nBeside normal Array methods, invokations can be used for mutations as well.\r\n\r\n    // Invoke collection with PB.Dom method\r\n    collection.invoke('setStyle', { color: 'brown', backgroundColor: 'purple });\r\n        \r\n\r\n### Style\r\n\r\nThere are two ways in *pbjs* to support CSS - static and transitional. Both work prefix free, allowing to focus on the input rather than cross browser issues.\r\n\r\n> Note that css properties are given in camel case\r\n\r\n1. setStyle / getStyle\r\n    \r\n        // Receive the current style\r\n        PB('element_id').getStyle('opacity');\r\n        \r\n        //  Adding style properties (including CSS3)\r\n        PB('element_id').setStyle('transform', 'rotate(30deg)');\r\n\r\n3. morph (Transitions)\r\n    \r\n        // Change the style over a time period\r\n        login.morph({                     \r\n           opacity: current/2        \r\n        }, 1.2 /* 1.2 seconds */, function( element ){        \r\n           element.remove();\r\n        });\r\n\r\n\r\n### Classes\r\n\r\nClasses are usefull for creating complex structures and maintaining large applications. Through the abstraction layer of a class - it's very easy to create new objects which inherits from another one.\r\n    \r\n    // Create an 'Animal' class\r\n    var Animal = PB.Class({\r\n        \r\n        // Class constructor\r\n        construct: function () {\r\n            \r\n            console.log( 'I am an animal' );\r\n        }        \r\n    });\r\n    \r\n    // Create an 'Ape' class, which extends the the former 'Animal'\r\n    var Ape = PB.Class( Animal, {\r\n        \r\n        construct: function () {            \r\n                   \r\n            console.log( 'I am an Ape' );\r\n        }        \r\n    });\r\n        \r\n    new Ape; \r\n        \r\n    // Result\r\n    > I'am an Ape\r\n\r\nIt's not just possible to access the inherited properties of the parent - but also get the result of an executed function directly.\r\n        \r\n    var Goat = PB.Class( Animal, {\r\n        \r\n        construct: function () {            \r\n            \r\n            this.parent();\r\n            console.log( 'I am a Goat' );\r\n        }        \r\n    });       \r\n    \r\n    new Goat;\r\n    \r\n    // Result\r\n    > I'am an Animal\r\n    > I'am a Goat\r\n\r\n\r\n### CSS Selector\r\n\r\nThe principle of *efficient coding* doesn't exclude DOM crawling with CSS selectors - it just enforces the developer to re-think about his workflow. In cases where you need use classes (prefix 'js-' !), you first select a parent element and then use the method '.find('.className')'. As a result it returns a collection of 'PB(elements)'.\r\n\r\n    // Using CSS selector\r\n    var entries = PB(document).find('.js-entries');\r\n\r\n\r\n### Compatibility\r\n\r\n- IE7+\r\n- Firefox 3+\r\n- Safari 4+\r\n- Opera\r\n- Chrome\r\n- Mobile (Tested with *Android, iPhone, Nokia, BlackBerry Tablet OS*)\r\n\r\n\r\n\r\nLicense\r\n-------\r\nThis project is under the MIT License.\r\n\r\n*Powered by Pluxbox*\r\n\r\n*Copyright 2011-2012, Niek Saarberg*\r\n"}